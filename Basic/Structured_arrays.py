#Introduce
#구조적 배열은 데이터 유형이 명명된 필드의 시퀀스로 구성된 단순한 데이터 유형의 조합인 ndarray

x = np.array([('Rex', 9, 81.0), ('Fido', 3, 27.0)],dtype=[('name', 'U10'), ('age', 'i4'), ('weight', 'f4')])
"""
이는 데이터 유형이 3개의 필드가 있는 구조인 길이2의 1차원 배열이다 name이라는 문자열 길이 10이하, age라는 32비트 정수, weight라는 비트부동소수점
"""
x[1]
x['age']
x['age']=5 #age 값 바뀜
"""
구조화된 데이터 유형은 c언어의 구조체를 모방하고 유사한 메모리 레이아웃을 공유할수 있도록 설계되엇다. 
C코드와 인터페이스하고 구조화된 버퍼의 저수준 조건을 위한 것이다.
"""

#Structured Datatypes / 구조화된 데이터 유형

"""
구조화된 데이터 유형은 필드 모음으로 해석되는 특정 길이의 바이트 시퀀스로 생각할 수 있다.
각 필드에는 구조 내에서 이름, 데이터 유형 및 바이트 오프셋이 있다.
필드의 데이터 유형은 다른 구조화된 데이터 유형을 포함한 모든 numpy게이터 유형일 수 있고
지정된 모양의 ndarray처럼 동작하는 하위 배열 데이터 유형일수도 있다.
필드의 오프셋은 임의적이며 필드가 겹칠 수도 있다.
이러한 오프셋은 일반적으로 numpy에 의해 자동으로 결정되지만 지정도 가능하다
"""

#Creation

#1. 튜플 목록, 필드당 하나의 튜플
"""
각 튜플은 모양이 선택사항인 형식을 갖는다. 문자열이고 데이터 유형으로 변환될 수 있는 모든 개체 일 수 있으며
하위 배열 모양을 지정하는 정수의 튜플이다. 
"""
np.dtype([('x', 'f4'), ('y', np.float32), ('z', 'f4', (2, 2))])

np.dtype([('x', 'f4'), ('', 'i4'), ('z', 'i8')]) # 이름이 비여있으면 필드 형식의 기본 이름 부여

#2. 쉼표로 구분된 dtype문자열
"""
문자열 dtype 사양은 문자열에서 사용할 수 있으며 쉼표로 구분할 수 있다.
필드의 itemsize 바이트 오프셋은 자동으로 결정, 필드이름은 기본 이름 부여
"""
np.dtype('i8, f4, S3') #이름 f0부터 자동 부여
np.dtype('3int8, float32, (2, 3)float64') #이름 f0부터 자동부여, 바이트 오프셋 자동결정

#3. 필드 매개변수 배열 사전
"""
필드의 바이트 오프셋과 구조의 항목 크기를 제어할 수 있기 때문에 가장 유연한 사양 형식

사전에는 'names' 및 'formats' 라는 두 개의 필수키와 'itemsize', 'aligned', 'titles'라는 4개의 선택적 키가 있다.
"""

#4. 필드 이름 사전
"""
이 형식의 사양을 사용하는 것은 권장되지 않지만 이전 numpy 코드에서 사용할 수 있음
사전의 키는 피르디름이고 같은 유형과 오프셋 지정하는 튜플
"""
np.dtype({'col1': ('i1', 0), 'col2': ('f4', 1)}) #권장되지는 않음

#구조화된 데이터 유형 조작 및 표시 - 필드 이름 목록은 names dtype객체의 속성에서 찾을수 있음.
d  = np.dtype([('x', 'i8'), ('y', 'f4')])
d.names

"""
필드이름은 names와 동일한 길이의 문자열 시퀀스를 사용하여 속성에 할당하여 수정가능

dtype객체는 딕셔너리와 유사한 속성을 가지고 fileds키가 필드이름이고 값이 각 필드의 dtype 및 바이트 오프셋을 포함하는 튜플
"""
d.fields

#자동 바이트 오프셋 및 정렬

"""
numpy는 align=True에 대한 키워드 인수로 지정 되었는지 여부에 따라 두가지 방법중 하나를 사용하여
구조화된 대이터유형의 필드 바이트 오프셋과 전체 항목 크기를 자동으로 결정

기본적으로(align=False) numpy는 각 필드가 이전 필드가 끝난  바이트 오프셋에서 시작하고 필드가 메모리에서 연속되도록 함께 묶는다.
"""

def print_offsets(d):
  print("offsets:", [d.fields[name][1] for name in d.names])
  print("itemsize:", d.itemsize)
print_offsets(np.dtype('u1, u1, i4, u1, i8, u2'))
"""
align=True 경우 많은 C 컴파일러 패드는 C구조체를 하는것과 같은 방식으로 numpy와 의지패드에게 구조를 설정한다.
정렬된 구조는 경우에 따라 데이터 유형의 크기가 증가하는 대신 기능향상을 제공한다.
패딩 바이트는 각 필디의 바이트 오프셋이 해당 필드 정렬의 베수가 되도록 필드 사이에 삽입되며,
이는 일반적으로 단순 데이터 유형일 경우 바이트 단위 필드 크기와 같다.
구조에는 항목 크기가 가장 큰 정렬의 배수가 되도록 후행 패딩도 추가한다.
"""
print_offsets(np.dtype('u1, u1, i4, u1, i8, u2', align=True))

#필드 제목
"""
필드 이름 외에도 필드에는 필드에 대한 추가 설명이나 별칭으로 사용되는 대체 이름인 연결된 제목이 있을 수 있다.
제목은 필드 이름처럼 배열을 인덱싱하는데 사용할 수 있다.

dtype 사양의 튜플 목록 형식을 사용할 때 제목을 추가하려면 필드 이름을 각각 필드의 제목과 필드이름이 되는 문자열 대신
두 문자열의 튜플로 지정할 수 있다.
"""
np.dtype([(('my title', 'name'), 'f4')])
"""
제 1형태의 사전 기반 사양을 사용하는 경우 제목은 'titles' 상술한바와 같이 추가키로 제공 가능
2형태 사전 기반 사양을 사용할 때 일반적인 2-요소 튜플 대신 3-요소 튜플을 제공하여 제목 제공할수 있음(datatype,offset,title)
"""
np.dtype({'name': ('i4', 0, 'my title')})

"""
dtype.fields는 어떤 제목을 사용하는 경우 사전키로 제목 포함
이는 제목이 있는 필드 사전에 두 번 표시된다는 것을 의미.
이 필드의 튜플 값에는 세 번째 요소인 필드제목도 있고, 이 때문에 names 속성은 필드 순서를 유지하지만 fields는 그렇지 않을수도 있으므로
names와 같이 제목을 나열하지 않는 dtype속성을 사용하여 필드를 반복하는 것이 좋음
"""
for name in d.names:
  print(d.fields[name][:2])
    
#유니온(조합) 유형
"""
구조화된 데이터 유형은 기본 유형을 갖도록 numpy에서 구현되지만 데이터 유형 개체에 설명된 dtype사양(base_dtype, dtype)의 형식을 사용하여
다른 numpy유형을 구조화된 유형으로 해석하는 것이 가능.여기에 원하는 기본 dtype이 있으며 필드와 플래그는 복사됨. 이 d타입은 c의 유니온과 유사
"""

#Indexing and Assignment to Structured arrays / 구조화된 배열에 대한 인덱싱 및 할당 

#구조화된 배열에 데이터 할당
#구조적 배열에 값을 할당하는 방법에는 튜플, 스칼라값,기타 구조적 배열 사용등이 있다.

#기본 유형(튜플)에서 할당
"""
가장 간단한 방법이다. 할당된 각 값은 배열의 필드수와 동일한 길이어야 하고 numpy의 브로드캐스팅 규칙을 트리거하는
목록이나 배열이 아니다. 튜플의 요소는 왼쪽에서 오른쪽으로 배열의 연속 필드에 할당된다.
"""
x = np.array([(1, 2, 3), (4, 5, 6)], dtype='i8, f4, f8')
x[1] = (7, 8, 9)
x

#스칼라에서 할당
"""
구조화된 요소에 할당된 스칼라는 모든 필드에 할당.
이것은 스칼라가 구조화된 배열에 할당되거나 구조화되지 않은 배열이 구조화 배열에 할당될 때 발생
"""

x = np.zeros(2,dtype='i8,f4,?,S1')
x[:]=3
x[:]=arange(2) #비교

twofield = np.zeros(2, dtype=[('A', 'i4'), ('B', 'i4')])
onefield = np.zeros(2, dtype=[('A', 'i4')])
nostruct = np.zeros(2, dtype='i4')
nostruct[:] = twofield #오류

#다른 구조적 배열에서 할당
"""
두 구조적 배열 간의 할당은 소스 요소가 튜플로 변환된 다음 대상 요소에 할당된 것처럼 발생
즉 소스 배열의 첫 번째 필드는 대상 배열의 첫 번째 필드에 할당되고
두번째도 마찬가지로 필드 이름에 관계없이 할당되는 방식
필드 수가 다른 구조적 배열은 서로 할당못함. 필드에 포함되지 않은 대상 구조의 바이트는 영향을 받지 않음
"""
a = np.zeros(3, dtype=[('a', 'i8'), ('b', 'f4'), ('c', 'S3')])
b = np.ones(3, dtype=[('x', 'f4'), ('y', 'S3'), ('z', 'O')])
b[:] = a
#부분배열과 관련된 할당-하위 배열인 필드에 할당 된 값은 먼저 하위 배열의 모양으로 브로드캐스트됨


#구조화된 배열 인덱싱

#개별 필드 엑세스 - 구조화된 배열의 개별 필드는 필드 이름으로 배열을 인덱싱하여 엑세스하고 수정 가능
x = np.array([(1, 2), (3, 4)], dtype=[('foo', 'i8'), ('bar', 'f4')])
x['foo'] = 10
y = x['bar']
y[:] = 11
y.dtype, y.shape, y.strides
x['a'].shape
y['a'].shape
x = np.zeros((2, 2), dtype=[('a', np.int32), ('b', np.float64, (3, 3))])
  
#여러 필드에 접근하기 - 다중 필드 색인이 있는 구조화된 배열은 색인화하고 할당가능. 색인은 필드 이름 목록
a = np.zeros(3, dtype=[('a', 'i4'), ('b', 'i4'), ('c', 'f4')])
a[['a', 'c']]
a[['a', 'c']] = (2, 3)
a
a[['a', 'c']] = a[['c', 'a']]

#구조적 스칼라를 얻기 위해 정수로 인덱싱
x = np.array([(1, 2., 3.)], dtype='i, f, f')
scalar = x[0]
scalar

x = np.array([(1, 2), (3, 4)], dtype=[('foo', 'i8'), ('bar', 'f4')])
s = x[0]
s['bar'] = 100
x

scalar = np.array([(1, 2., 3.)], dtype='i, f, f')[0]
scalar[0]
scalar[1] = 4
scalar.item(), type(scalar.item())

#레코드 배열
"""
선택적인 편의로numpy는 ndarray 하위 클래스를 제공하여 인덱스 대신 속성별로 구조화된 배열의 필드에 엑세스 가능
레코드 배열은 배열에서 얻은 구조화된 스칼라에 대한 속성으로 필드 엑세스를 허용하는 특수 데이터 유형 사용
recarray 생성하기 위한 기능 제공
 numpy.rec.array. 사용하여 레코드 배열
"""
recordarr = np.rec.array([(1, 2., 'Hello'), (2, 3., "World")],dtype=[('foo', 'i4'),('bar', 'f4'), ('baz', 'S10')])

recordarr.bar 
recordarr[1:2]

rec.array([(2, 3., b'World')],dtype=[('foo', '<i4'), ('bar', '<f4'), ('baz', 'S10')])

recordarr[1:2].foo
recordarr.foo[1:2]
recordarr[1].baz

arr = np.array([(1, 2., 'Hello'), (2, 3., "World")],dtype=[('foo', 'i4'), ('bar', 'f4'), ('baz', 'S10')])
recordarr = np.rec.array(arr) #레코드 배열로 변환


#도우미 함수 
